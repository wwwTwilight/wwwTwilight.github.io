[{"content":"这是题外话：鉴于很多时候app不认中文路由，从这篇文章开始，后续所有的文章都采用英文路由，之前的就不管了，反正除了我，应该也没什么人看😭\n下面是正文\ngit 代理问题 很多人应该都遇到了在使用git的时候出现的代理问题，明明可以直接登上github，但是git clone和git push之类的操作却总是提示超时，这是怎么个事。\n解决方案 原因其实是你的git工具没有设置代理，Git 是独立的命令行工具，它不会自动使用系统代理，其使用的底层库（如 libcurl）默认不走任何代理。\n通过以下的命令可以使用代理\n1git config --global http.proxy 127.0.0.1:7890 2git config --global https.proxy 127.0.0.1:7890 关于最后的端口以及ip，127.0.0.1是本地地址的一个特殊地址，就是每一台电脑都有这个地址，其作用主要是用于在网络中表示自己（类似localhost），而7890则是代理的端口号，具体可以看clash的端口号，默认是7890。\n其他 除了添加git代理的命令，删除和查看同样是比较重要的，这里也给出命令\n1git config --global --unset http.proxy 2git config --global --unset https.proxy 3git config --global --get http.proxy 4git config --global --get https.proxy 针对linux虚拟机的额外说明 如果你使用的是linux虚拟机，那么你可能会发现，你添加了代理之后，git还是无法使用代理，这是为什么呢？\n这个具体原因我也不是很清楚，但是可以记录一下解决方案，我是直接取消了git的代理设置，在物理机上开启了clash的allow LAN模式，然后虚拟机在设置里直接连接代理，这样就可以使用了。\n","permalink":"http://localhost:1313/posts/gitproxyproblem/gitproxyproblem/","summary":"\u003cp\u003e这是题外话：鉴于很多时候app不认中文路由，从这篇文章开始，后续所有的文章都采用英文路由，之前的就不管了，反正除了我，应该也没什么人看😭\u003c/p\u003e\n\u003cp\u003e下面是正文\u003c/p\u003e","title":"关于git的代理问题"},{"content":"神经网络与机器学习的最大区别 神经网络不需要人工提取特征，而是通过神经网络自动提取特征\n神经网络的层框架 输入层，隐藏层，输出层\ntensorflow和numpy的使用 tensorflow是深度学习框架，numpy是科学计算库，二者可以结合使用\ntensorflow的使用 1import tensorflow as tf 2import numpy as np 3 4# 创建矩阵 5a = tf.Tensor([[1,2,3,4,5,6],[1,2,3,4,5,6]], shape=(1,3), dtype=float32) 6 7# 转成numpy 8a = a.numpy() numpy的使用 1import numpy as np 2 3# 创建一个数组 4a = np.array([1,2,3,4,5,6]) 5b = np.array([1,2,3,4,5,6]) 6c = a + b 7 8# 矩阵 9a = np.array([[1,2,3,4,5,6],[1,2,3,4,5,6]]) 10b = np.array([[1,2,3,4,5,6],[1,2,3,4,5,6]]) 11c = a + b 12 13# 打印数组 14print(c) python中矩阵的常用操作（会持续更新）\n1import numpy as np 2 3# 矩阵乘法 4a = np.array([[1,2,3,4,5,6],[1,2,3,4,5,6]]) 5b = np.array([[1,2,3,4,5,6],[1,2,3,4,5,6]]) 6c = np.dot(a, b) 7 8# 转秩 9a = a.T 10 11# 打印数组 12print(c) 利用tensorFlow构建神经网络 1import tensorflow as tf 2import numpy as np 3 4# 创建各个层 5x = np. array([[200.0, 17.0], 6 [300.0, 23.0], 7 [400.0, 31.0], 8 [500.0, 45.0], 9 [600.0, 53.0], 10 [700.0, 57.0], 11 [800.0, 60.0]]) 12y = np.array([[1.0], 13 [2.0], 14 [3.0], 15 [4.0], 16 [5.0], 17 [6.0], 18 [7.0]]) 19 20layer_1 = Dense(units=3, activation=\u0026#34;sigmoid\u0026#34;) 21a1 = layer_1(x) 22layer_2 = Dense(units=1, activation=\u0026#34;sigmoid\u0026#34;) 23a2 = layer_2(a1) 24 25# 连接成神经网络 26model = sequential([layer_1, layer_2]) 27 28# 训练神经网络 29model.compile(optimizer=\u0026#34;adam\u0026#34;, loss=\u0026#34;mse\u0026#34;) 30model.fit(x, y, epochs=1000) 前向传播在numpy的实现 激活函数 激活函数的作用是引入非线性因素，使得神经网络可以逼近任何非线性函数\n常用的激活函数有：sigmoid，relu，Linear activation function\n适用范围如图所示，sigmod用于二元，线性用于有正有负，relu用于正数。\n激活函数的选择 relu函数在深度学习中使用最多，因为其计算简单，且不会出现梯度消失的问题（梯度消失问题是指在反向传播过程中，梯度在经过多层神经网络后逐渐趋近于0，导致网络无法学习或者学习缓慢），但是对于二元分类问题，还是用sigmoid函数比较好。\n为什么需要激活函数 因为神经网络中的神经元是线性的，如果不用激活函数，那么无论神经网络有多少层，其输出都是线性的，无法逼近非线性函数。\nsoftmax回归算法 softmax回归算法用于多分类问题，其输出是各个类别的概率分布，且概率之和为1。\n公式：\n$$ softmax(x_i) = \\frac{e^{x_i}}{\\sum_{j=1}^{n}e^{x_j}} $$ 损失函数 softmax回归算法的损失函数 tensorflow实现softmax回归算法 不推荐使用tensorflow实现softmax回归算法 因为tensorflow已经封装好了softmax回归算法，可以直接使用。\n1model.compile(loss = BinaryCrossentropy(from_logits = True)) 注意这样子的话如果设置 from_logits=true，输出层应该设置为线性激活函数，这样子神经网络训练出来的结果就是z的数值，随后，需要调用f_x = tf.nn.softmax (logits)，将结果转换为a（概率值）\n这样操作的目的是，由于计算机本身计算的精度有限，有些时候如果先存储结果再计算会导致精度损失，如果按照原本的方法，先计算了sigmoid函数的结果，再用那个函数的结果，计算损失函数，就会损失精度，因此直接在损失函数内部计算，避免精度损失，这个 from_logits=true 就是告诉损失函数，我给你的结果还没有经过 sigmoid 函数，你帮我计算一下损失函数。\n我懂了，原来是这样，首先，先说明原来的方法弊端是什么，由于计算机本身计算的精度有限，有些时候如果先存储结果再计算会导致精度损失，如果按照原本的方法，先计算了sigmoid函数的结果，再用那个函数的结果，计算损失函数，就会损失精度，使用from_logits=true和线性激活函数，相当于只对z进行预测，输出的结果就是z，所以神经网络计算的结果其实是z，然后，在预测阶段，我们不可能直接使用z，因为我们需要的是一个概率值，所以，我们需要使用f_x = tf.nn.softmax (logits)，将结果转换为a（概率值），这样，我们就可以得到一个概率值，然后，我们就可以使用这个概率值进行预测了。\n其实以后都可以按这个来，因为更加精确。\nAdam算法 优化梯度下降学习率的算法，是梯度下降的一点改进，按照下面的代码自动调用即可\n代码如下\n模型优化 对于一个简单的预测模型，我们无法确定他的预测的结果是好还是坏，所以我们需要一个评价的标准。\nJTest JTest最简单的方式就是将原始数据三七分成，三成是测试集，七成是训练集，将训练集的数据用于训练，测试集的数据输入到模型中，得到预测结果，然后与实际结果进行对比，得到一个误差，这个误差就是JTest。但是这样子做也是有缺陷的，如果我们使用测试集的数据进行验证，测试集在某种程度上也成了模型训练过程的一部分（测试集原本的作用是测试模型的泛化能力），这可能导致模型对测试集过拟合，导致评价的结果可能表现不佳。\n为了解决这个问题，交叉验证的方法被提了出来，按照622的比例分别作为训练集，交叉验证集，测试集。\n用六成数据训练，交叉验证集数据用于选择参数，测试集数据用于测试模型的泛化能力。这样子测试集的Cost函数就可以更好地反映模型的泛化能力。\n方差和偏差 方差和偏差是衡量模型预测结果与实际结果之间的差距，偏差是指模型预测结果与实际结果之间的差距，方差是指模型预测结果之间的差距。高方差往往代表过拟合，高偏差往往代表欠拟合。\n","permalink":"http://localhost:1313/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E7%AE%97%E6%B3%95/","summary":"\u003ch1 id=\"神经网络与机器学习的最大区别\"\u003e神经网络与机器学习的最大区别\u003c/h1\u003e\n\u003cp\u003e神经网络不需要人工提取特征，而是通过神经网络自动提取特征\u003c/p\u003e\n\u003ch1 id=\"神经网络的层框架\"\u003e神经网络的层框架\u003c/h1\u003e\n\u003cp\u003e输入层，隐藏层，输出层\u003c/p\u003e\n\u003cimg src = \"../pics/深度学习框架图.png\"/\u003e\n\u003ch1 id=\"tensorflow和numpy的使用\"\u003etensorflow和numpy的使用\u003c/h1\u003e\n\u003cp\u003etensorflow是深度学习框架，numpy是科学计算库，二者可以结合使用\u003c/p\u003e","title":"机器学习之更高级的算法"},{"content":"机器学习笔记 尽量写完，这个是Coursea的机器学习课程，会持续更新的。\n好吧其实写的很散，比较乱，但是这一个部分不是很难，笔记基本都是罗列关键词，定稿了，就这样吧，进军深度学习。\n监督式机器学习与非监督式机器学习 监督式机器学习 通过输入一系列的x和y，形成一个模型，能够通过一个新的x来预测y的数值。\n其中一种方式——回归，通过拟合一条直线或者曲线来预测y的值。\n另一种方式——分类，通过拟合一个边界来预测其所属类别。 线性回归 成本函数：评价拟合程度，数值应该尽可能小 $$ J(w, b) = \\frac{\\sum_{i = 1}^{m} (\\hat{y}(x^{(i)}) - y^{(i)})^{2}}{2m} $$ 梯度下降：通过不断调整w和b，使得成本函数的值不断减小，最终达到最小值 $$ w = w - \\alpha \\frac{\\partial J(w, b)}{\\partial w} $$ $$ b = b - \\alpha \\frac{\\partial J(w, b)}{\\partial b} $$ 向量化 将多个x和y的值合并成一个矩阵，通过矩阵运算来计算成本函数和梯度下降。在python，这个实现方式使用numpy库。能够极大程度地提高运算速度。由于是使用GPU进行矩阵运算\n缩放 由于变量之间的大小水平有所差异，为了让数据更加可观，降低某些变量的灵敏度，需要将变量进行缩放。\n有两种方式，一种是均值归一化，将变量的值减去均值，然后除以标准差。另一种是归一化，将变量的值除以最大值。\n检查梯度下降是否收敛 两种方式：\n绘图检查，看随着迭代次数增加，成本函数是否收敛到某个数值 检查梯度下降的步长是否足够小，如果步长足够小，说明梯度下降已经收敛 特征工程 通过特征工程，将原始数据转化为对模型更有用的数据，例如知道房子土地的长度和宽度，可以提取一个面积的特征。\n多项式回归 就是将高次项视为一个单一的特征，例如将x1和x2的平方视为一个特征。然后根据普通的线性回归进行计算。\n逻辑回归 sigmoid函数，将y的值映射到0-1之间，用于分类问题。\n$$ \\hat{y} = \\sigma(w^{T}x + b) = \\frac{1}{1 + e^{-w^{T}x - b}} $$ 成本函数 $$ J(w, b) = -\\frac{1}{m} \\sum_{i = 1}^{m} {y^{(i)} \\log(\\hat{y}^{(i)}) + (1 - y^{(i)}) \\log(1 - \\hat{y}^{(i)})} $$ 梯度下降的公式和线性回归一样，只是成本函数不同。\n非监督式机器学习 通过输入一系列的x，通过聚类的方式，将相似的x归为一类，程序需要自己发现这些相似性。\n过度拟合 当模型过于复杂，导致模型在训练集上表现很好，但在测试集上表现很差，这就是过度拟合。\n更多的数据 通过增加数据量，可以减少过度拟合。\n特征选择 通过选择更少的有效的特征，可以减少过度拟合。\n正则化 降低所有参数的大小\n通过在成本函数中添加一个正则化项，来限制模型的复杂度，从而避免过度拟合。\n$$ J(w, b) = \\frac{1}{2m} \\sum_{i = 1}^{m} (\\hat{y}(x^{(i)}) - y^{(i)})^{2} + \\frac{\\lambda}{2m} \\sum_{j = 1}^{n} w_{j}^{2} $$ lambda是正则化参数，用于控制正则化的程度，如果lambda过大，会导致模型过于简单，如果lambda过小，会导致模型过于复杂。\n此时梯度下降的公式变为：\n$$ w = w - \\alpha \\left( \\frac{\\partial J(w, b)}{\\partial w} + \\frac{\\lambda}{m} w \\right) $$ b的不变，因为正则化一般不考虑b。\n","permalink":"http://localhost:1313/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"机器学习笔记\"\u003e机器学习笔记\u003c/h1\u003e\n\u003cp\u003e尽量写完，这个是Coursea的机器学习课程，会持续更新的。\u003c/p\u003e\n\u003cp\u003e好吧其实写的很散，比较乱，但是这一个部分不是很难，笔记基本都是罗列关键词，定稿了，就这样吧，进军深度学习。\u003c/p\u003e","title":"机器学习入门笔记"},{"content":"按照网上的教程更换clash内核，但是发现内核更换后，clash无法启动，界面直接报错，根据我的查找和学习，发现问题在于clash找不到新的内核，改了名字也没有用，接下来可以按照本文的内容做：\n注意以下所有的内容在clash完全关闭的情况下完成\n内核下载 这个其实网上很多现成的教程，但是为了文章的完整性，我还是稍微讲一下，首先，去到clash core的GitHub页面clash core，然后找到你的电脑对应的版本（这里补充一点，mac的话选哪个darwin的），下载之后是一个可执行文件。\n内核更换 下载好内核之后，将内核文件放到clash的目录下，直接打开你clash的安装目录，找到内核的文件，如下图\nmac\nwin（文件名可能不是clash-core.exe，比如我的就是clash-win64.exe，但是应该很明显）\nresources\\static\\files\\win\\x64\\clash-core.exe 接下来将原本的内核改一个名字，比如clash-core-old.exe之类的，以防万一，然后不管原来那个内核，将新的内核放到那个目录下，改名字为clash-core.exe（根据你旧内核的名字改，旧内核是什么名字就改成什么名字，比如我就是clash-win64.exe），然后打开clash，按照网上的帖子说，理论上应该就可以正常使用了。\n但是我的不可以，而且似乎还有不少人遇见了这个情况\n内核绑定 这个原因是clash应用找不到内核，接下来是解决方式，首先是windows的，先退出clash，然后打开自带的文件资源管理器，在地址栏输入 %USERPROFILE%\\.config\\mihomo 进入文件夹，如果这里显示你没有这个文件夹，那也十分正常，可以直接进行下一步，如果有的话，就要返回上一级然后把这个文件夹删除，再进行下一步\n打开 powershell ，执行以下命令，执行完成后会提示 创建的符号链接\ncmd /c mklink /d \u0026#34;%USERPROFILE%\\.config\\mihomo\u0026#34; \u0026#34;%USERPROFILE%\\.config\\clash\u0026#34; 然后就解决了，重新打开clash，就可以正常使用了。\n对于mac而言其实也差不多，打开终端，输入以下命令：\n先用这个指令把原来的内核文件相关的内容删了，或者你手动删除\nrm -rf ~/.config/mihomo 然后输入这个指令，建立符号链接\nln -s ~/.config/clash ~/.config/mihomo 然后重新打开clash，就可以正常使用了\n参考资料 https://blog.leginn.top/archives/Cfw_Hhm.html\n","permalink":"http://localhost:1313/posts/clash%E5%86%85%E6%A0%B8%E6%9B%B4%E6%8D%A2/clash%E5%86%85%E6%A0%B8%E6%9B%B4%E6%8D%A2/","summary":"\u003cp\u003e按照网上的教程更换clash内核，但是发现内核更换后，clash无法启动，界面直接报错，根据我的查找和学习，发现问题在于clash找不到新的内核，改了名字也没有用，接下来可以按照本文的内容做：\u003c/p\u003e","title":"Clash内核更换"},{"content":"本帖旨在收集数家互联网大厂的实习硬性要求技术\n","permalink":"http://localhost:1313/posts/%E5%A4%A7%E5%8E%82%E5%AE%9E%E4%B9%A0%E7%A1%AC%E6%80%A7%E8%A6%81%E6%B1%82%E6%8A%80%E6%9C%AF/%E5%A4%A7%E5%8E%82%E5%AE%9E%E4%B9%A0%E7%A1%AC%E6%80%A7%E8%A6%81%E6%B1%82%E6%8A%80%E6%9C%AF/","summary":"\u003cp\u003e本帖旨在收集数家互联网大厂的实习硬性要求技术\u003c/p\u003e","title":"大厂实习硬性要求技术"},{"content":"SQL 注入攻击及BERT模型 SQL 注入攻击原理 SQL注入攻击（SQL Injection, SQLi）是一种发生在应用程序和数据库层的安全漏洞，是一种常用的数据库攻击手段，其利用特殊构造的SQL语句进行拼接，从而执行恶意SQL代码，如果在设计程序的时候没有进行防备，通过这些语句，黑客可以获取到数据库的数据以及其中的信息，甚至可以修改数据库中的数据，导致数据库遭到严重的破坏。\n案例 常见的SQL注入攻击方式有：\n内联SQL注入 通过注释等方式，跳过某些验证，例如一个登陆的查询语句 1SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39; AND password = \u0026#39;123\u0026#39; 如果用户输入的用户名是admin\u0026rsquo; AND 1=1 \u0026ndash; ，密码随意，那么拼接后的SQL语句就变成了\n1SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39; AND 1=1 -- \u0026#39; AND password = \u0026#39;123\u0026#39; 因为-- 是SQL中的注释符号，后面的内容都会被注释掉，所以密码这一项就不再起作用了，这样就可以绕过密码的验证，直接登陆到系统中。\n盲SQL注入 通过改变查询和观察页面内容变化，判断SQL查询是否成功执行，例如一个查询语句\n1SELECT * FROM products WHERE name LIKE \u0026#39;%[用户输入]%\u0026#39;; 这时候如果攻击者想要知道是否存在一个名为users的表，可以通过改变查询语句，观察页面内容的变化来判断，通过输入以下内容\n1a\u0026#39; AND (SELECT \u0026#39;test\u0026#39; FROM users) = \u0026#39;test\u0026#39; –- 如果这之后页面返回正常内容，那么说明存在users表，否则说明不存在。\n联合查询SQL注入 通过UNION SELECT语句，攻击者可以进行额外的查询，将查询结果合并到一起，例如一个查询语句\n1SELECT * FROM products WHERE name = \u0026#39;用户输入\u0026#39;; 此时，攻击者可以输入以下内容（假设数据类型能够匹配）\n1\u0026#39; UNION SELECT username, password FROM users –- 这样就可以将users表中的内容也显示出来。\n当前主流的防御方法 预处理语句：通过参数化查询，将SQL代码和用户输入严格分离，防止SQL注入攻击。 1stmt, err := db.Prepare(\u0026#34;SELECT * FROM users WHERE username = ? AND password = ?\u0026#34;) 2if err != nil { 3 log.Fatal(err) 4} 5rows, err := stmt.Query(username, password) 使用对象关系映射框架：通过ORM框架，将SQL语句和用户输入严格分离，防止SQL注入攻击。 1var user User 2db.Where(\u0026#34;username = ? AND password = ?\u0026#34;, username, password).First(\u0026amp;user) 输入验证：对用户输入进行严格的限制和验证（比如禁止输入\u0026rsquo;\u0026rsquo; \u0026ndash; #等字符），防止SQL注入攻击。\n最小权限原则：通过限制数据库用户的权限，使得即使发生了SQL注入攻击，攻击者也无法对数据库进行过度的操作。\n但是上述的所有方法都有无法防御的情况，因此在实际的使用中，需要结合多种方法进行防御。\nBERT模型与SQL注入攻击 BERT模型简介 BERT（Bidirectional Encoder Representations from Transformers）是一种基于Transformer的预训练语言模型，其目的在于完成自然语言理解任务。它通过双向编码器来学习语言中的上下文信息，从而实现双向上下文理解，能够同时考虑句子中的前后文信息，从而更好地理解语言语义。\nBERT模型在SQL注入攻击中的应用 BERT模型应对SQL注入攻击的主要思想是利用BERT模型的自然语言处理能力，攻击者通过恶意的SQL代码破坏数据库，而BERT模型可以通过将攻击检测转换为NLP任务，让BERT识别输入是否包含SQL注入攻击。\n具体而言，首先需要收集SQL查询数据，其中包含正常的SQL语句和恶意的SQL注入语句，将其进行分词和向量化，转换为BERT模型可以处理的输入形式，然后通过BERT模型进行训练，使其能够识别出恶意的SQL注入语句。\n训练完成后，将待检测的SQL语句输入到BERT模型中，模型会输出一个概率值，表示该SQL语句是否包含SQL注入攻击，从而实现对SQL注入攻击的检测。\nBERT模型在SQL注入攻击检测中的优势 相比传统的应对SQL注入攻击的方法，BERT模型具有明显的优势\n由于BERT具有强大的自然语言处理能力，能够更好地理解SQL语句的语义，相比传统的防御方式，能够更准确地识别出SQL注入攻击以及各种攻击的变种。 某些SQLi的攻击方式复杂，例如使用/**/注释符，传统的防御方式难以识别，而BERT模型可以更好地处理这些复杂的SQL注入攻击。 传统方法在某些规则方面较为严格，可能会误判常规的SQL语句，而BERT由于可以理解SQL语句的语义，可以更好地识别出SQL注入攻击，降低误判率。 BERT模型在SQL注入攻击检测中的局限性 尽管BERT在SQL注入攻击检测中表现出显著的优势，但是也存在一些局限性\nBERT需要大量的训练数据，而收集高质量的SQL注入攻击数据是一项非常困难的工作。 BERT模型需要大量的计算资源，对于实时性要求较高的场景，BERT模型可能无法满足需求。 BERT模型只提供一个概率值，并不能直接判断SQL语句是否包含SQL注入攻击，需要根据概率值进行进一步的判断和处理。 防御方法 误报率 维护成本 对变种 SQLi 的防御能力 执行效率 参数化查询 低 低 弱 高 ORM 低 低 弱 中等 输入验证 中 低 弱 高 BERT 低 高 强 低 ","permalink":"http://localhost:1313/posts/sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%8F%8Abert%E6%A8%A1%E5%9E%8B/sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%8F%8Abert%E6%A8%A1%E5%9E%8B/","summary":"\u003ch1 id=\"sql-注入攻击及bert模型\"\u003eSQL 注入攻击及BERT模型\u003c/h1\u003e\n\u003ch2 id=\"sql-注入攻击原理\"\u003eSQL 注入攻击原理\u003c/h2\u003e\n\u003cp\u003eSQL注入攻击（SQL Injection, SQLi）是一种发生在应用程序和数据库层的安全漏洞，是一种常用的数据库攻击手段，其利用特殊构造的SQL语句进行拼接，从而执行恶意SQL代码，如果在设计程序的时候没有进行防备，通过这些语句，黑客可以获取到数据库的数据以及其中的信息，甚至可以修改数据库中的数据，导致数据库遭到严重的破坏。\u003c/p\u003e","title":"SQL注入攻击及BERT模型"},{"content":"记录一些git常用的指令，主要是防止忘记，内容很乱，仅供参考，后面有空写一个完整的git以及github使用教程\n用户名配置 git config --global user.name \u0026#34;用户名\u0026#34; git config --global user.email 用户邮箱 同一个origin下设置不同的push和fetch → study git:(master) git remote add origin git@github.com:git/git → study git:(master) git remote set-url --add --push origin git@github.com:MY_REPOSITY/git → study git:(master) git remote -v origin git@github.com:git/git (fetch) origin git@github.com:MY_REPOSITY/git (push) git add 将文件加入到暂存区中\ngit add . git commit 将暂存区的文件提交到本地仓库\ngit commit -m \u0026#34;提交信息\u0026#34; 虽然但是，上面两个步骤在vscode里面可以直接提交\n创建新分支 git checkout -b 分支名 tag 创建tag\ngit tag v1.0 附注标签\ngit tag -a v1.0 -m \u0026#34;标签信息\u0026#34; 修改历史版本 git commit --amend 可以修改最近一次的commit信息\n清理悬空的commit git fsck --lost-found 拉取信息 Clone 拉取完整的仓库到本地目录，可以指定分支，深度。 Fetch 将远端某些分支最新代码拉取到本地，不会执行 merge 操作，会修改 refs/remote 内的分支信息，如果需要和本地代码合并需要手动操作。 Pull 拉取远端某分支，并和本地代码进行合并，操作等同于 git fetch + git merge，也可以通过 git pull \u0026ndash;rebase 完成 git fetch + git rebase 操作。可能存在冲突，需要解决冲突。 合并 merge的两种方式\nFast-forward：不会产生一个新的merge节点，而是保留原来的历史。 git merge 分支名 --ff-only No-ff：将合并的内容放到一个新的节点。 git merge 分支名 --no-ff 不想写了，这里贴一个网上叫雷小帅的大佬写的git详细教程得了😇😇😇😇😇\n大家好，我是雷小帅。\n最近群里有几位老哥私我，有没有好的 git 入门资料，想学一下。\n偶然看到这个很棒的教程推荐给大家，大家可以看一下，另外还有一个不错的 git 入门网站，也推荐给大家，可以搭配使用。\nhttps://learngitbranching.js.org/?locale=zh_CN\nGit简介 实用主义 准备阶段 常用操作 git clone git config git branch git checkout git status git add git commit git push git pull git log git tag .gitignore 小结 深入探索 基本概念 工作区（Working Directory） 本地版本库（Local Repository） 暂存区（stage） 远程版本库（Remote Repository） 以上概念之间的关系 分支（Branch） 主分支（Master） 标签（Tag） HEAD 操作文件 git add git commit git mv git rm git status 操作分支 git branch git merge git checkout git stash 操作历史 git log git cherry-pick git reset git rebase git revert git diff git reflog 远程版本库连接 git init git remote git fetch 问题排查 git blame git bisect 更多操作 git submodule git gc git archive Git简介 Git 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 Git 来做自己的文档版本管理工具。\n大概是大二的时候开始接触和使用Git，从一开始的零接触到现在的重度依赖，真是感叹 Git 的强大。\nGit 的api很多，但其实平时项目中90%的需求都只需要用到几个基本的功能即可，所以本文将从 实用主义 和 深入探索 2个方面去谈谈如何在项目中使用 Git，一般来说，看完 实用主义 这一节就可以开始在项目中动手用。\n说明：本文的操作都是基于 Mac 系统\n实用主义 准备阶段 进入 Git官网 下载合适你的安装包，安装好 Git 后，打开命令行工具，进入工作文件夹（为了便于理解我们在系统桌面上演示），创建一个新的demo文件夹。\n进入 Github网站 注册一个账号并登录，进入 我的博客，点击 Clone or download，再点击 Use HTTPS ，复制项目地址 https://github.com/gafish/gafish.github.com.git 备用。\n再回到命令行工具，一切就绪，接下来进入本文的重点。\n常用操作 所谓实用主义，就是掌握了以下知识就可以玩转 Git，轻松应对90%以上的需求。以下是实用主义型的Git命令列表，先大致看一下\ngit clone git config git branch git checkout git status git add git commit git push git pull git log git tag 接下来，将通过对 我的博客 仓库进行实例操作，讲解如何使用 Git 拉取代码到提交代码的整个流程。\ngit clone 从git服务器拉取代码\ngit clone https://github.com/gafish/gafish.github.com.git 代码下载完成后在当前文件夹中会有一个 gafish.github.com 的目录，通过 cd gafish.github.com 命令进入目录。\ngit config 配置开发者用户名和邮箱\ngit config user.name gafish git config user.email gafish@qqqq.com 每次代码提交的时候都会生成一条提交记录，其中会包含当前配置的用户名和邮箱。\ngit branch 创建、重命名、查看、删除项目分支，通过 Git 做项目开发时，一般都是在开发分支中进行，开发完成后合并分支到主干。\ngit branch daily/0.0.0 创建一个名为 daily/0.0.0 的日常开发分支，分支名只要不包括特殊字符即可。\ngit branch -m daily/0.0.0 daily/0.0.1 如果觉得之前的分支名不合适，可以为新建的分支重命名，重命名分支名为 daily/0.0.1\ngit branch 通过不带参数的branch命令可以查看当前项目分支列表\ngit branch -d daily/0.0.1 如果分支已经完成使命则可以通过 -d 参数将分支删除，这里为了继续下一步操作，暂不执行删除操作\ngit checkout 切换分支\ngit checkout daily/0.0.1 切换到 daily/0.0.1 分支，后续的操作将在这个分支上进行\ngit status 查看文件变动状态\n通过任何你喜欢的编辑器对项目中的 README.md 文件做一些改动，保存。\ngit status 通过 git status 命令可以看到文件当前状态 Changes not staged for commit:（改动文件未提交到暂存区）\nOn branch daily/0.0.1 Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: README.md no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) git add 添加文件变动到暂存区\ngit add README.md 通过指定文件名 README.md 可以将该文件添加到暂存区，如果想添加所有文件可用 git add . 命令，这时候可通过 git status 看到文件当前状态 Changes to be committed: （文件已提交到暂存区）\nOn branch daily/0.0.1 Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md git commit 提交文件变动到版本库\ngit commit -m \u0026#39;这里写提交原因\u0026#39; 通过 -m 参数可直接在命令行里输入提交描述文本\ngit push 将本地的代码改动推送到服务器\ngit push origin daily/0.0.1 origin 指代的是当前的git服务器地址，这行命令的意思是把 daily/0.0.1 分支推送到服务器，当看到命令行返回如下字符表示推送成功了。\nCounting objects: 3, done. Delta compression using up to 8 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), completed with 1 local objects. To https://github.com/gafish/gafish.github.com.git * [new branch] daily/0.0.1 -\u0026gt; daily/0.0.1 现在我们回到Github网站的项目首页，点击 Branch:master 下拉按钮，就会看到刚才推送的 daily/00.1 分支了\ngit pull 将服务器上的最新代码拉取到本地\ngit pull origin daily/0.0.1 如果其它项目成员对项目做了改动并推送到服务器，我们需要将最新的改动更新到本地，这里我们来模拟一下这种情况。\n进入Github网站的项目首页，再进入 daily/0.0.1 分支，在线对 README.md 文件做一些修改并保存，然后在命令中执行以上命令，它将把刚才在线修改的部分拉取到本地，用编辑器打开 README.md ，你会发现文件已经跟线上的内容同步了。\n如果线上代码做了变动，而你本地的代码也有变动，拉取的代码就有可能会跟你本地的改动冲突，一般情况下 Git 会自动处理这种冲突合并，但如果改动的是同一行，那就需要手动来合并代码，编辑文件，保存最新的改动，再通过 git add .和 git commit -m 'xxx' 来提交合并。\ngit log 查看版本提交记录\ngit log 通过以上命令，我们可以查看整个项目的版本提交记录，它里面包含了提交人、日期、提交原因等信息，得到的结果如下：\ncommit c334730f8dba5096c54c8ac04fdc2b31ede7107a Author: gafish \u0026lt;gafish@qqqq.com\u0026gt; Date: Wed Jan 11 09:44:13 2017 +0800 Update README.md commit ba6e3d21fcb1c87a718d2a73cdd11261eb672b2a Author: gafish \u0026lt;gafish@qqqq.com\u0026gt; Date: Wed Jan 11 09:31:33 2017 +0800 test ..... 提交记录可能会非常多，按 J 键往下翻，按 K 键往上翻，按 Q 键退出查看\ngit tag 为项目标记里程碑\ngit tag publish/0.0.1 git push origin publish/0.0.1 当我们完成某个功能需求准备发布上线时，应该将此次完整的项目代码做个标记，并将这个标记好的版本发布到线上，这里我们以 publish/0.0.1 为标记名并发布，当看到命令行返回如下内容则表示发布成功了\nTotal 0 (delta 0), reused 0 (delta 0) To https://github.com/gafish/gafish.github.com.git * [new tag] publish/0.0.1 -\u0026gt; publish/0.0.1 .gitignore 设置哪些内容不需要推送到服务器，这是一个配置文件\ntouch .gitignore .gitignore 不是 Git 命令，而在项目中的一个文件，通过设置 .gitignore 的内容告诉 Git 哪些文件应该被忽略不需要推送到服务器，通过以上命令可以创建一个 .gitignore 文件，并在编辑器中打开文件，每一行代表一个要忽略的文件或目录，如：\ndemo.html build/ 以上内容的意思是 Git 将忽略 demo.html 文件 和 build/ 目录，这些内容不会被推送到服务器上\n小结 通过掌握以上这些基本命令就可以在项目中开始用起来了，如果追求实用，那关于 Git 的学习就可以到此结束了，偶尔遇到的问题也基本上通过 Google 也能找到答案，如果想深入探索 Git 的高阶功能，那就继续往下看 深入探索 部分。\n深入探索 基本概念 工作区（Working Directory） 就是你在电脑里能看到的目录，比如上文中的 gafish.github.com 文件夹就是一个工作区\n本地版本库（Local Repository） 工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。\n暂存区（stage） 本地版本库里存了很多东西，其中最重要的就是称为 stage（或者叫index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 master 的一个指针叫 HEAD。\n远程版本库（Remote Repository） 一般指的是 Git 服务器上所对应的仓库，本文的示例所在的github仓库就是一个远程版本库\n以上概念之间的关系 工作区、暂存区、本地版本库、远程版本库之间几个常用的 Git 操作流程如下图所示：\n分支（Branch） 分支是为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改\n主分支（Master） 前面提到过 master 是 Git 为我们自动创建的第一个分支，也叫主分支，其它分支开发完成后都要合并到 master\n标签（Tag） 标签是用于标记特定的点或提交的历史，通常会用来标记发布版本的名称或版本号（如：publish/0.0.1），虽然标签看起来有点像分支，但打上标签的提交是固定的，不能随意的改动，参见上图中的1.0 / 2.0 / 3.0\nHEAD HEAD 指向的就是当前分支的最新提交\n以上概念了解的差不多，那就可以继续往下看，下面将以具体的操作类型来讲解 Git 的高阶用法\n操作文件 git add 添加文件到暂存区\ngit add -i 通过此命令将打开交互式子命令系统，你将看到如下子命令\n***Commands*** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help 通过输入序列号或首字母可以选择相应的功能，具体的功能解释如下：\nstatus：功能上和 git add -i 相似，没什么鸟用 update：详见下方 git add -u revert：把已经添加到暂存区的文件从暂存区剔除，其操作方式和 update类似 add untracked：可以把新增的文件添加到暂存区，其操作方式和 update 类似 patch：详见下方 git add -p diff：比较暂存区文件和本地版本库的差异，其操作方式和 update 类似 quit：退出 git add -i 命令系统 help：查看帮助信息 git add -p 直接进入交互命令中最有用的 patch 模式\n这是交互命令中最有用的模式，其操作方式和 update 类似，选择后 Git 会显示这些文件的当前内容与本地版本库中的差异，然后您可以自己决定是否添加这些修改到暂存区，在命令行 Stage deletion [y,n,q,a,d,/,?]? 后输入 y,n,q,a,d,/,? 其中一项选择操作方式，具体功能解释如下：\ny：接受修改 n：忽略修改 q：退出当前命令 a：添加修改 d：放弃修改 /：通过正则表达式匹配修改内容 ?：查看帮助信息 git add -u 直接进入交互命令中的 update 模式\n它会先列出工作区 修改 或 删除 的文件列表，新增 的文件不会被显示，在命令行 Update\u0026gt;\u0026gt; 后输入相应的列表序列号表示选中该项，回车继续选择，如果已选好，直接回车回到命令主界面\ngit add --ignore-removal . 添加工作区 修改 或 新增 的文件列表， 删除 的文件不会被添加\ngit commit 把暂存区的文件提交到本地版本库\ngit commit -m \u0026#39;第一行提交原因\u0026#39; -m \u0026#39;第二行提交原因\u0026#39; 不打开编辑器，直接在命令行中输入多行提交原因\ngit commit -am \u0026#39;提交原因\u0026#39; 将工作区 修改 或 删除 的文件提交到本地版本库， 新增 的文件不会被提交\ngit commit --amend -m \u0026#39;提交原因\u0026#39; 修改最新一条提交记录的提交原因\ngit commit -C HEAD 将当前文件改动提交到 HEAD 或当前分支的历史ID\ngit mv 移动或重命名文件、目录\ngit mv a.md b.md -f 将 a.md 重命名为 b.md ，同时添加变动到暂存区，加 -f 参数可以强制重命名，相比用 mv a.md b.md 命令省去了 git add 操作\ngit rm 从工作区和暂存区移除文件\ngit rm b.md 从工作区和暂存区移除文件 b.md ，同时添加变动到暂存区，相比用 rm b.md 命令省去了 git add 操作\ngit rm src/ -r 允许从工作区和暂存区移除目录\ngit status git status -s 以简短方式查看工作区和暂存区文件状态，示例如下：\nM demo.html ?? test.html git status --ignored 查看工作区和暂存区文件状态，包括被忽略的文件\n操作分支 git branch 查看、创建、删除分支\ngit branch -a 查看本地版本库和远程版本库上的分支列表\ngit branch -r 查看远程版本库上的分支列表，加上 -d 参数可以删除远程版本库上的分支\ngit branch -D 分支未提交到本地版本库前强制删除分支\ngit branch -vv 查看带有最后提交id、最近提交原因等信息的本地版本库分支列表\ngit merge 将其它分支合并到当前分支\ngit merge --squash 将待合并分支上的 commit 合并成一个新的 commit 放入当前分支，适用于待合并分支的提交记录不需要保留的情况\ngit merge --no-ff 默认情况下，Git 执行\u0026quot;快进式合并\u0026quot;（fast-farward merge），会直接将 Master分支指向 Develop 分支，使用 --no-ff 参数后，会执行正常合并，在 Master分支上生成一个新节点，保证版本演进更清晰。\ngit merge --no-edit 在没有冲突的情况下合并，不想手动编辑提交原因，而是用 Git 自动生成的类似 Merge branch 'test' 的文字直接提交\ngit checkout 切换分支\ngit checkout -b daily/0.0.1 创建 daily/0.0.1 分支，同时切换到这个新创建的分支\ngit checkout HEAD demo.html 从本地版本库的 HEAD（也可以是提交ID、分支名、Tag名） 历史中检出 demo.html 覆盖当前工作区的文件，如果省略 HEAD 则是从暂存区检出\ngit checkout --orphan new_branch 这个命令会创建一个全新的，完全没有历史记录的新分支，但当前源分支上所有的最新文件都还在，真是强迫症患者的福音，但这个新分支必须做一次 git commit操作后才会真正成为一个新分支。\ngit checkout -p other_branch 这个命令主要用来比较两个分支间的差异内容，并提供交互式的界面来选择进一步的操作，这个命令不仅可以比较两个分支间的差异，还可以比较单个文件的差异。\ngit stash 在 Git 的栈中保存当前修改或删除的工作进度，当你在一个分支里做某项功能开发时，接到通知把昨天已经测试完没问题的代码发布到线上，但这时你已经在这个分支里加入了其它未提交的代码，这个时候就可以把这些未提交的代码存到栈里。\ngit stash 将未提交的文件保存到Git栈中\ngit stash list 查看栈中保存的列表\ngit stash show stash@{0} 显示栈中其中一条记录\ngit stash drop stash@{0} 移除栈中其中一条记录\ngit stash pop 从Git栈中检出最新保存的一条记录，并将它从栈中移除\ngit stash apply stash@{0} 从Git栈中检出其中一条记录，但不从栈中移除\ngit stash branch new_banch 把当前栈中最近一次记录检出并创建一个新分支\ngit stash clear 清空栈里的所有记录\ngit stash create 为当前修改或删除的文件创建一个自定义的栈并返回一个ID，此时并未真正存储到栈里\ngit stash store xxxxxx 将 create 方法里返回的ID放到 store 后面，此时在栈里真正创建了一个记录，但当前修改或删除的文件并未从工作区移除\n$ git stash create 09eb9a97ad632d0825be1ece361936d1d0bdb5c7 $ git stash store 09eb9a97ad632d0825be1ece361936d1d0bdb5c7 $ git stash list stash@{0}: Created via \u0026#34;git stash store\u0026#34;. 操作历史 git log 显示提交历史记录\ngit log -p 显示带提交差异对比的历史记录\ngit log demo.html 显示 demo.html 文件的历史记录\ngit log --since=\u0026#34;2 weeks ago\u0026#34; 显示2周前开始到现在的历史记录，其它时间可以类推\ngit log --before=\u0026#34;2 weeks ago\u0026#34; 显示截止到2周前的历史记录，其它时间可以类推\ngit log -10 显示最近10条历史记录\ngit log f5f630a..HEAD 显示从提交ID f5f630a 到 HEAD 之间的记录，HEAD 可以为空或其它提交ID\ngit log --pretty=oneline 在一行中输出简短的历史记录\ngit log --pretty=format:\u0026#34;%h\u0026#34; 格式化输出历史记录\nGit 用各种 placeholder 来决定各种显示内容，我挑几个常用的显示如下：\n%H: commit hash %h: 缩短的commit hash %T: tree hash %t: 缩短的 tree hash %P: parent hashes %p: 缩短的 parent hashes %an: 作者名字 %aN: mailmap的作者名 %ae: 作者邮箱 %ad: 日期 (\u0026ndash;date= 制定的格式) %ar: 日期, 相对格式(1 day ago) %cn: 提交者名字 %ce: 提交者 email %cd: 提交日期 (\u0026ndash;date= 制定的格式) %cr: 提交日期, 相对格式(1 day ago) %d: ref名称 %s: commit信息标题 %b: commit信息内容 %n: 换行 git cherry-pick 合并分支的一条或几条提交记录到当前分支末梢\ngit cherry-pick 170a305 合并提交ID 170a305 到当前分支末梢\ngit reset 将当前的分支重设（reset）到指定的 \u0026lt;commit\u0026gt; 或者 HEAD\ngit reset --mixed \u0026lt;commit\u0026gt; --mixed 是不带参数时的默认参数，它退回到某个版本，保留文件内容，回退提交历史\ngit reset --soft \u0026lt;commit\u0026gt; 暂存区和工作区中的内容不作任何改变，仅仅把 HEAD 指向 \u0026lt;commit\u0026gt;\ngit reset --hard \u0026lt;commit\u0026gt; 自从 \u0026lt;commit\u0026gt; 以来在工作区中的任何改变都被丢弃，并把 HEAD 指向 \u0026lt;commit\u0026gt;\ngit rebase 重新定义分支的版本库状态\ngit rebase branch_name 合并分支，这跟 merge 很像，但还是有本质区别，看下图：\n合并过程中可能需要先解决冲突，然后执行 git rebase --continue\ngit rebase -i HEAD~~ 打开文本编辑器，将看到从 HEAD 到 HEAD~~ 的提交如下\npick 9a54fd4 添加commit的说明 pick 0d4a808 添加pull的说明 # Rebase 326fc9f..0d4a808 onto d286baa # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec = run command (the rest of the line) using shell # 将第一行的 pick 改成 Commands 中所列出来的命令，然后保存并退出，所对应的修改将会生效。如果移动提交记录的顺序，将改变历史记录中的排序。\ngit revert 撤销某次操作，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交\ngit revert HEAD 撤销前一次提交操作\ngit revert HEAD --no-edit 撤销前一次提交操作，并以默认的 Revert \u0026quot;xxx\u0026quot; 为提交原因\ngit revert -n HEAD 需要撤销多次操作的时候加 -n 参数，这样不会每次撤销操作都提交，而是等所有撤销都完成后一起提交\ngit diff 查看工作区、暂存区、本地版本库之间的文件差异，用一张图来解释\ngit diff --stat 通过 --stat 参数可以查看变更统计数据\ntest.md | 1 - 1 file changed, 1 deletion(-) git reflog reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作、已经被删除的commit记录，跟 git log 的区别在于它不能查看已经删除了的commit记录\n远程版本库连接 如果在GitHub项目初始化之前，文件已经存在于本地目录中，那可以在本地初始化本地版本库，再将本地版本库跟远程版本库连接起来\ngit init 在本地目录内部会生成.git文件夹\ngit remote git remote -v 不带参数，列出已经存在的远程分支，加上 -v 列出详细信息，在每一个名字后面列出其远程url\ngit remote add origin https://github.com/gafish/gafish.github.com.git 添加一个新的远程仓库，指定一个名字，以便引用后面带的URL\ngit fetch 将远程版本库的更新取回到本地版本库\ngit fetch origin daily/0.0.1 默认情况下，git fetch 取回所有分支的更新。如果只想取回特定分支的更新，可以指定分支名。\n问题排查 git blame 查看文件每行代码块的历史信息\ngit blame -L 1,10 demo.html 截取 demo.html 文件1-10行历史信息\ngit bisect 二分查找历史记录，排查BUG\ngit bisect start 开始二分查找\ngit bisect bad 标记当前二分提交ID为有问题的点\ngit bisect good 标记当前二分提交ID为没问题的点\ngit bisect reset 查到有问题的提交ID后回到原分支\n更多操作 git submodule 通过 Git 子模块可以跟踪外部版本库，它允许在某一版本库中再存储另一版本库，并且能够保持2个版本库完全独立\ngit submodule add https://github.com/gafish/demo.git demo 将 demo 仓库添加为子模块\ngit submodule update demo 更新子模块 demo\ngit gc 运行Git的垃圾回收功能，清理冗余的历史快照\ngit archive 将加了tag的某个版本打包提取\ngit archive -v --format=zip v0.1 \u0026gt; v0.1.zip --format 表示打包的格式，如 zip，-v 表示对应的tag名，后面跟的是tag名，如 v0.1。\n\u0026ndash; End \u0026ndash;\n","permalink":"http://localhost:1313/posts/git%E4%BD%BF%E7%94%A8/git%E4%BD%BF%E7%94%A8/","summary":"\u003cp\u003e记录一些git常用的指令，主要是防止忘记，内容很乱，仅供参考，后面有空写一个完整的git以及github使用教程\u003c/p\u003e\n\u003ch1 id=\"用户名配置\"\u003e用户名配置\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egit config --global user.name \u0026#34;用户名\u0026#34;\ngit config --global user.email 用户邮箱\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"同一个origin下设置不同的push和fetch\"\u003e同一个origin下设置不同的push和fetch\u003c/h1\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e→ study git:(master) git remote add origin git@github.com:git/git\n\n→ study git:(master) git remote set-url --add --push origin git@github.com:MY_REPOSITY/git\n\n→ study git:(master) git remote -v\n\norigin git@github.com:git/git (fetch)\n\norigin git@github.com:MY_REPOSITY/git (push)\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"git-add\"\u003egit add\u003c/h1\u003e\n\u003cp\u003e将文件加入到暂存区中\u003c/p\u003e","title":"Git使用"},{"content":"简单记一下golang的语法，看看能不能速成\n第一个HelloWorld 1package main // 入口文件 2 3import \u0026#34;fmt\u0026#34; // 导入标准包 4 5func main() { 6 fmt.Println(\u0026#34;Hello World\u0026#34;) 7} 运行：go run main.go或者go run .执行全部\n顺带一提go的函数就是像上面那样子声明的\n变量声明 1var a int = 10 // 声明变量a，类型为int，值为10，是最完整的形式 2var b = 10 // 声明变量b，类型自动识别，这里就是int，值为10 3c := 10 // 声明变量c，类型自动识别，这里就是int，值为10，这种形式只能在函数里面这样子写，在函数外面只能用var，也就是上一种形式 常量 1const a = 10 2const ( 3 a = 10 4 b = 20 5) 数据类型 1// 整型 2int 3int8 4int16 5int32 6int64 7uint 8uint8 9// 直接用int就行 10 11float32 12float64 13 14bool 15 16string 17 18rune // int32 19byte // uint8 20 21// 复数 22complex64 23complex128 输出 1fmt.Println(\u0026#34;Hello World\u0026#34;) // 输出并换行 2fmt.Printf(\u0026#34;Hello World\\n\u0026#34;) // 输出并换行 3fmt.Printf(\u0026#34;a 的类型是 %T\\n\u0026#34;, a) // 输出a的类型 4fmt.Printf(\u0026#34;a 的值是 %v\\n\u0026#34;, a) // 输出a的值 占位符内容详细参考这里\n运算符 1// 算术运算符 2+ - * / % ++ -- 3 4// 关系运算符 5== != \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= 6 7// 逻辑运算符 8\u0026amp;\u0026amp; || ! 9 10// 位运算符 11\u0026amp; | ^ \u0026lt;\u0026lt; \u0026gt;\u0026gt; 条件语句 1// if 2func main() { 3 if a \u0026gt; 10 { 4 fmt.Println(\u0026#34;a 大于 10\u0026#34;) 5 } else if a \u0026lt; 10 { 6 fmt.Println(\u0026#34;a 小于 10\u0026#34;) 7 } else { 8 fmt.Println(\u0026#34;a 等于 10\u0026#34;) 9 } 10} 11 12// 可以在if中初始化变量，方式如下，只支持在这个if下使用 13if a := 10; a \u0026gt; 10 { 14 fmt.Println(\u0026#34;a 大于 10\u0026#34;) 15} else if a \u0026lt; 10 { 16 fmt.Println(\u0026#34;a 小于 10\u0026#34;) 17} else { 18 fmt.Println(\u0026#34;a 等于 10\u0026#34;) 19} 20 21// switch case 22func main() { 23 // 比起C++，这个相当于自带break 24 switch a { 25 case 1: 26 fmt.Println(\u0026#34;a 等于 1\u0026#34;) 27 case 2: 28 fmt.Println(\u0026#34;a 等于 2\u0026#34;) 29 default: 30 fmt.Println(\u0026#34;a 不等于 1 和 2\u0026#34;) 31 } 32} 循环语句 go只有for循环\n1// for 2func main() { 3 for i := 0; i \u0026lt; 10; i++ { 4 fmt.Println(i) 5 } 6} 7 8// for range 9func main() { 10 // 这个相当于C++的for each 11 for i, v := range arr { 12 fmt.Println(i, v) 13 } 14} 函数 1// 声明函数 2func 函数名(a int, b int) 返回值列表 { // 返回值可以省略 3 // 函数体 4 return 返回值 5} 6 7// 返回多个值 8func 函数名(a int, b int) (int, int) { 9 // 函数体 10 return b, a 11} 12 13// 命名返回值 14func 函数名(参数列表) (返回值列表) { 15 // 函数体 16 return 返回值 17} 18 19// 可变参数 20func 函数名(参数列表 ...参数类型) { 21 22} 23 24// 函数可以作为值放到变量中 25func sum(a int, b int, transform func(int) int) int { 26 return transform(a) + transform(b) 27} 数组 1// 声明数组 2var arr [5]int // 声明一个长度为5的int数组 3arr := [5]int{1, 2, 3, 4, 5} // 声明并初始化一个长度为5的int数组，长度是不可变的 4arr := [...]int{1, 2, 3, 4, 5} // 声明并初始化一个长度为5的int数组，长度由编译器自动计算 slice可以像vector一样\n1a := make([]int, 5) // 声明一个长度为5的int数组 2a := []int{1, 2, 3, 4, 5} // 声明并初始化一个长度为5的int数组 3a = append(a, 1, 2, 3) // 在数组后面添加元素 4a[0] = 5 // 修改数组元素 map 1m := map[string]int{ //[key]value 2 \u0026#34;a\u0026#34;: 1, 3 \u0026#34;b\u0026#34;: 2, 4 \u0026#34;c\u0026#34;: 3, 5} 6m := make(map[string]int) // 声明一个map，没有初始值 结构体 1type Person struct { 2 Name string 3 Age int 4} 5// 方法 6func (p Person) SayHello() { // 第一个参数相当于是this指针 7 fmt.Println(\u0026#34;Hello, my name is\u0026#34;, p.Name, \u0026#34;and I am\u0026#34;, p.Age, \u0026#34;years old.\u0026#34;) 8} 9func (p *Person) SetName(name string) { // 这个函数不是定义在结构体内的，因此使用的时候如果涉及赋值操作，需要传递引用 10 p.Name = name 11} 12// 初始化结构体 13p := Person{ 14 Name: \u0026#34;Tom\u0026#34;, 15 Age: 18, 16} 17// 访问结构体成员 18p.Name 19p.Age 20// 修改结构体成员 21p.Name = \u0026#34;Jerry\u0026#34; 22// 调用结构体方法 23p.SayHello() 24p.SetName(\u0026#34;Jerry\u0026#34;) 指针 1a := 10 2b := \u0026amp;a // b是指向a的指针 3*b = 20 // 修改指针指向的值 4fmt.Println(a) // 输出20 5// 或者 6var a int= 20 /* 声明实际变量 */ 7var ip *int /* 声明指针变量 */ 8ip = \u0026amp;a /* 指针变量的存储地址 */ 接口 1type Animal interface { 2 SayHello() // 声明一个接口 3} 4 5type Dog struct { 6 Name string 7} 8 9type Cat struct { 10 Name string 11} 12 13func (d Dog) SayHello() { 14 fmt.Println(\u0026#34;Hello, my name is\u0026#34;, d.Name) 15} 16 17func (c Cat) SayHello() { 18 fmt.Println(\u0026#34;Hello, my name is\u0026#34;, c.Name) 19} 20 21func main() { 22 var a Animal 23 var b Animal 24 a = Dog{Name: \u0026#34;Tom\u0026#34;} 25 b = Cat{Name: \u0026#34;Jerry\u0026#34;} 26 a.SayHello() 27 b.SayHello() 28} 错误处理 1func main() { 2 n, err := fmt.Println(\u0026#34;dd\u0026#34;) 3 if err != nil { 4 // 正常 5 } else { 6 // 异常 7 } 8} 并发 1func main() { 2 go func2() 3 func1() 4} 5 6func func1() { 7 time.Sleep(500 * time.Second) 8 fmt.Println(\u0026#34;func1\u0026#34;) 9} 10 11func func2() { 12 fmt.Println(\u0026#34;func2\u0026#34;) 13} channels管道通信，这个ch有点像是栈，后进先出\n1func func1(ch chan string){ 2 ch \u0026lt;- \u0026#34;func1\u0026#34; 3} 4func func2(ch chan string){ 5 ch \u0026lt;- \u0026#34;func2\u0026#34; 6} 7func main() { 8 ch := make(chan string) 9 go func1(ch) 10 res1 := \u0026lt;-ch 11 go func2(ch) 12 res2 := \u0026lt;-ch 13 fmt.Println(res1) 14 fmt.Println(res2) 15} 结果是：func1 func2\n1func func1(ch chan string) { 2\tch \u0026lt;- \u0026#34;func1\u0026#34; 3} 4func func2(ch chan string) { 5\tch \u0026lt;- \u0026#34;func2\u0026#34; 6} 7func main() { 8\tch := make(chan string) 9\tgo func1(ch) 10\tgo func2(ch) 11\tres1 := \u0026lt;-ch 12\tres2 := \u0026lt;-ch 13\tfmt.Println(res1) 14\tfmt.Println(res2) 15} 结果是：func2 func1\n","permalink":"http://localhost:1313/posts/golang%E5%85%A5%E9%97%A8/golang%E5%85%A5%E9%97%A8/","summary":"\u003cp\u003e简单记一下golang的语法，看看能不能速成\u003c/p\u003e\n\u003ch1 id=\"第一个helloworld\"\u003e第一个HelloWorld\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003epackage\u003c/span\u003e \u003cspan class=\"nx\"\u003emain\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 入口文件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;fmt\u0026#34;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 导入标准包\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Hello World\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e运行：\u003ccode\u003ego run main.go\u003c/code\u003e或者\u003ccode\u003ego run .\u003c/code\u003e执行全部\u003c/p\u003e\n\u003cp\u003e顺带一提go的函数就是像上面那样子声明的\u003c/p\u003e","title":"golang入门"},{"content":"没什么时间了，快速突击一下，笔记就记在这里\n速通资料网盘下载\n速通PDF文件查看\n与国赛的区别 美赛与国赛的区别主要如下：\n相较于国赛，美赛在结果上相对较为灵活 美赛十分重视假设的设立，可能需要对于假设进行验证，对于其合理性进行分析，并进行灵敏度分析，解释假设的优缺点等 灵敏度分析说简单点就是控制变量法，假设一个函数f(x,y,z)=w，那么灵敏性分析就是假设x,y,z中有一个变量发生变化，看w的变化情况，以此来判断哪个变量对w的影响最大。\n使用英语 美赛对于模型的检验十分看重，对于模型的建立可以十分灵活，可以有创造性，但是检验一定要详细，检验越多越好 美赛题目 A：连续型 B：离散型 C：大数据 D：运筹学 E：可持续性 F：政策 AB两题是很难的，需要专业知识，除非恰好与自己的专业相关，否则不建议选择\nC题与国赛C题类似，可以考虑\nD涉及概念比较多，不太推荐\nE和F一般是涉及评价之类的问题，可能会比较简单，可以考虑\n常用模型 结合SPSSPRO学习\n评价类 TOPSIS 利用原始数据进行综合评价参考资料，这里面写的很详细，直接看就行\n熵权法 一种客观的赋值方法，参考资料\n预测类 bp神经网络回归 假设有一系列数据（x1～xn）（已知），然后有一个指标S，其中S是x1～xn的函数，现在已知x1～xn的值，求S的值，可以使用bp神经网络回归，从而确定S与其所有的参数的函数关系参考资料\nLotka-Volterra 捕食-被捕食模型，主要用于确定两个对象之间数目的相互作用关系，描述两个相互作用系统的动态平衡和周期性变化，尤其交互呈现正负反馈关系时，可以确定一个平衡的点，一般用于预测参考资料\n多元线性回归 这个没什么好讲的\n随机森林 决策树一条路走下来，分类结果可能会有偏差，随机森林就是在有多个变量的情况下，通过随机挑选若干个变量，然后建立多个决策树，然后多个决策树求出来结果，数量多的结果就是最终结果\n马尔可夫 参考资料\n大概的意思是未来的状态与过去的无关，主要是通过转移矩阵确定？\nARIMA 预测一个值随着时间的变化参考资料\n优化类 蒙特卡洛模拟 这是一种模拟的方法，采用随机数的方式，模拟结果出现的概率，通过大量的模拟，最终根据模拟的结果，确定优化的结果参考资料\n线性规划 线性规划就是线性函数在给定约束条件下的最优化问题，给定约束条件即可\n蚁群算法 参考资料\n也算是优化的算法吧，也是通过类似模拟的方法，每一轮根据解的质量优劣更新信息素浓度，最后经过不断的迭代（感觉有点像贪心算法？），确定一个最优的路径，从而确定最优结果\n未分类 写作要求 整体框架 首先，美赛没有固定的格式，相对可以比较灵活，以下是官网的翻译：\n摘要：评委们非常重视摘要，获奖论文通常会根据摘要的质量与其他论文区分开来。 要写出好的摘要，请想象读者会根据您的摘要选择是否阅读论文正文：您在摘要中的简洁陈述应该激发读者了解您工作的细节。 您应该最后写总结，因为它应该清楚地描述您解决问题的方法，并且最突出的是您最重要的结论。确保在解决问题后计划时间写出全面而清晰的总结。 仅仅重述竞赛问题或从引言中剪切粘贴样板的摘要通常被认为是薄弱的。 总体而言：团队的解决方案应该清晰、简洁、有条理，以便读者能够轻松理解解决方案的过程和结论。关键陈述应提出主要想法和结果。 目录可帮助读者预览报告的组织结构。（也就是一定要有目录） 酌情对问题进行重述。（要问题重述，跟国赛一样） 对所有变量和假设进行清晰的阐述。（对于假设需要详细） 陈述并证明与问题相关的合理假设。 提出问题分析，激发或证明所使用模型的合理性。 在解决方案的正文中总结推导、计算或说明性示例，并在适当的附录中留下冗长的推导和/或计算和数据。 讨论如何测试模型，包括误差分析、灵敏度和/或稳定性。 讨论您的模型或方法的任何明显的优点或缺点。 明确提供结论并报告结果。 文档资源和参考文献。 推荐框架如下\n标题 摘要 目录 引言 问题背景 问题重述 文献综述（非必须） 工作思路 模型假设和合理性验证 符号说明 模型一 数据预处理 模型建立 模型求解 模型二 灵敏度检验 模型的评价及推广 结论 参考文献 附录 标题 两段式—— 。。。：。。。常见于O奖，或者也可以延续国赛的方式，基于xxx模型的xxx问题研究，或者有水平的可以风趣一点\n英语中，标题每一个单词的首字母要大写，除了介词和连词（on，via，and，of，the）\n摘要书写 总体框架： 开头段：针对什么问题，建立了什么模型\n针对问题一，建立的模型+求解的过程+得到的数值+意义\n针对问题二，针对问题三，……\n结尾总结段：模型的优缺点，灵敏度分析等，以及可以改进的方面（非必要）\n模型名称，算法名称，关键变量，模型结果常常要加粗注意摘要页控制在一页内\n摘要的要求，专有名词不能出错，每一个小问要给出具体的结果和建立的模型，包括设置参数和求解，越精炼越好，尽可能写在一页以内，不要有表格和图片\n开头段：介绍问题和所建立的模型 With the development of XX, the XX problem has become a hot topic in the paper. In order to solve the XX problem, this paper establishes/utilizes the XX model and solves to obtain XX.\n随着XX的发展XX问题已经成为一个热点话题。为了解决XX问题，本文建立/利用了XX模型，求解得到XX.\n第一段不必太长，4到6行即可。\n求解得到的结果这里不用太具体，概括一下就好\n中间段 For question I, For question II, For question III\nFirst, Second, Third\n每一段都要描述清楚一小问的求解过程，包括建立的模型以及关键的参数（可以加印象分）还有求解的结果以及结果的意义，这里的结果要具体\n结尾段 Finally, our model\u0026hellip;\u0026hellip;\n最后，我们的模型较好地解決了YX问题，模型在XX情况下能够准确求解YY，而在XX情况下需要考虑……。\n可以写一下模型的大体情况，包括在哪些条件下表现比较好，哪些条件下表现比较差，简单的进行灵敏度分析和优缺点分析。\n关键词 跟国赛一样，4-6个\n引言 背景，简单地对于赛题进行补充说明，推荐写完正文之后再写引言，注意不要提到任何的模型，也不要重复陈述题目已经给出的背景\n问题重述，跟国赛一样，不要照抄题目，不要替换专有名词\nConsidering the background information and restricted conditions identified in the problem statement, we need to solve the following problems:\nProblem 1 Problem 2 Problem 3 文献综述，文献综述就是把关于当前问题的现有研究成果做个概述。首先需要阅读大量解决该问题的论文，其次得用自己的话总结出来。除非想冲O奖，否则别写这部分。一来竞赛时间有限不可能去阅读大量论文；二来能力有限，不一定能写好总结。小技巧：去搜相关论文，一般发表的论文都会有文献综述部分，照着别人的综述用自己的话描述一遍即可。\n工作思路，类似于问题分析，一定要制作一个思路图，把整个流程画出来\n模型假设与说明 除了写假设，还要验证其合理性\n符号说明 跟国赛一样，三线表\n数据描述 非必须，如果自己收集了数据，或者题目给了数据，可以在这个部分讲一下，可以做一下可视化以及数据预处理还有一些简单的分析\n其中C题一般数据量比较大，可能要写\n模型的建立与求解 每一个问题可以按照模型进行命名，这样观感比较好\n模型可以是很简单的但是一定要具体，有可能的话可以适当创新\n求解的算法一定要讲清楚，而且还需要横向对比，讲清楚为什么选择这一个算法，可以适当添加伪代码\n重要：美赛十分重视结果分析，不能只把结果放出来，要解析结果有什么含义，揭示了什么现象，进行详细的分析，越详细越好\n灵敏度分析和误差分析 英语是 Sensitivity analysis and error analysis\n灵敏度分析，主要说明误差的问题，要说明为什么选择这个参数进行灵敏度分析，分析的结果可以说明什么\n模型的评价与推广 评价模型的优缺点，也可以评价建模过程中的优缺点\n描述模型完成了什么工作，达到了什么目的，得出了什么规律，为今后的工作提供了什么思路，有什么实际用途\n模型或思路设计的简洁适用，效率高\n本文模型具有很强的创新性\n模型的计算结果准确，精度高\n模型考虑的系统全面，有很强的实用性\n对模型进行了各类检验、稳定性高\n模型本身具有的一些优点\n受某些因素限制，某些情况考虑\n本文考虑的因素较为理想，降低了模型的普适度\n由于系统考虑了某些因素，导致模型较为复杂，计算时间效率较低\n模型本身的一些缺陷\n结论 国赛没有，中心思想的重申，研究结果和主要观点的归纳\n参考文献 跟国赛一样，注意格式，严格按照要求（知网和谷歌学术），数目应该不少于6篇，然后注意，不可以出现中文，如果是中文文章，注意换成英文，顺带一提，插图也不可以有中文，还有文章中要有引用上标\n附录 美赛附录是算在篇幅以内的，所以不可以太长，然后注意代码的注释不可以是中文的\n其他内容 有些时候美赛需要写一些其他的文章，比如说写一个杂志，或者写一个报告，这种要注意格式，包括书信格式什么的，然后注意排版，不要有太多的空行，注意美观\n","permalink":"http://localhost:1313/posts/%E6%95%B0%E6%A8%A1%E7%BE%8E%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%A8%A1%E7%BE%8E%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e没什么时间了，快速突击一下，笔记就记在这里\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://pan.baidu.com/s/1CLbl6ADy7sVjhuiJgqeiKA?pwd=a67c\"\u003e速通资料网盘下载\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"../三天拿下数学建模美赛M奖【公众号：数模加油站】.pdf\" target=\"_blank\"\u003e速通PDF文件查看\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"与国赛的区别\"\u003e与国赛的区别\u003c/h1\u003e\n\u003cp\u003e美赛与国赛的区别主要如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e相较于国赛，美赛在结果上相对较为灵活\u003c/li\u003e\n\u003cli\u003e美赛十分重视假设的设立，可能需要对于假设进行验证，对于其合理性进行分析，并进行灵敏度分析，解释假设的优缺点等\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e灵敏度分析说简单点就是控制变量法，假设一个函数f(x,y,z)=w，那么灵敏性分析就是假设x,y,z中有一个变量发生变化，看w的变化情况，以此来判断哪个变量对w的影响最大。\u003c/p\u003e","title":"数模美赛学习笔记"},{"content":"由于本人认为浏览器的收藏功能十分的不好用，这篇将会收录一些比较有用的网站，供日常使用（持续更新中）\n网站导航 LaTeX 基础教学\nLaTeX表格快速制作（简）\nLaTeX表格快速制作\n常用LaTeX符号\n书本 电诊书目收录\nz-library导航（不保证随时能用）\n代码工具 三剑客组件 一些好看的网页组件，可以直接使用\n代码美图生成\n游戏相关 L4D2地图下载\n什亭之匣\n学习 三角函数公式大全\n前端学习指南\n现代C++相关学习资源\nCS自学指南\n摸鱼 无尽开车\nFML霉运记录\n其他 快速简历生成\n论文AIGC率查询\nyesPlayMusic音乐播放器 一个好看的播放器，可以与网易云同步\npdf -\u0026gt; word\n","permalink":"http://localhost:1313/posts/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/","summary":"\u003cp\u003e由于本人认为浏览器的收藏功能十分的不好用，这篇将会收录一些比较有用的网站，供日常使用（持续更新中）\u003c/p\u003e\n\u003ch1 id=\"网站导航\"\u003e网站导航\u003c/h1\u003e\n\u003ch2 id=\"latex\"\u003eLaTeX\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/456055339\"\u003e基础教学\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.tablesgenerator.com/\"\u003eLaTeX表格快速制作（简）\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.latex-tables.com/\"\u003eLaTeX表格快速制作\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/zgj926503/article/details/52757631\"\u003e常用LaTeX符号\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"书本\"\u003e书本\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://guide.samuka007.xyz/articles/ebooks/\"\u003e电诊书目收录\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.tboxn.com/sitetag/zlibrary%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99\"\u003ez-library导航（不保证随时能用）\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"代码工具\"\u003e代码工具\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://neumorphism.io/#e0e0e0\"\u003e三剑客组件\u003c/a\u003e 一些好看的网页组件，可以直接使用\u003c/p\u003e","title":"网站导航"},{"content":"本篇文章用于记录如何书写新的博文，以及如何使用本博客，以免我未来忘了\n开始写之前 如果需要创建博客内容，请使用 hugo new content content/posts/（文章名）/（文章名）.md\n在写完内容要发布的时候，记得将前面的draft标签改为false，否则文章不会发布\n关于浏览，使用 hugo server -D 可以在本地预览博客，使用 hugo server 可以在本地预览已经发布的博客\n写文章 博客的书写采用markdown语法，可以参考Markdown语法进行书写。\n数学公式 公式书写与latex相通\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n对于存在3个以上花括号的公式，请用\u0026lt;div\u0026gt;包裹起来。\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 表格的使用 Foo Foo Foo Foo Foo Foo Foo Foo Foo 列表的使用 a b c 代码块的使用 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4class Node { 5public: 6 int val[2]; // 存放节点中的值，最多两个 7 Node* child[3]; // 存放子节点，最多三个 8 bool isTwoNode; // 标记是否为2节点 9 10 Node(int value) { 11 val[0] = value; 12 val[1] = -1; // -1表示没有第二个值 13 for (int i = 0; i \u0026lt; 3; i++) { 14 child[i] = nullptr; 15 } 16 isTwoNode = true; // 初始为2节点 17 } 18 19 bool isLeaf() { 20 return (child[0] == nullptr \u0026amp;\u0026amp; child[1] == nullptr \u0026amp;\u0026amp; child[2] == nullptr); 21 } 22}; 23 24class TwoThreeTree { 25private: 26 Node* root; 27 28 // 插入节点 29 Node* insert(Node* node, int value) { 30 if (node == nullptr) { 31 return new Node(value); 32 } 33 34 if (node-\u0026gt;isLeaf()) { 35 return splitAndInsert(node, value); 36 } 37 38 if (value \u0026lt; node-\u0026gt;val[0]) { 39 node-\u0026gt;child[0] = insert(node-\u0026gt;child[0], value); 40 } else if (node-\u0026gt;isTwoNode || value \u0026lt; node-\u0026gt;val[1]) { 41 node-\u0026gt;child[1] = insert(node-\u0026gt;child[1], value); 42 } else { 43 node-\u0026gt;child[2] = insert(node-\u0026gt;child[2], value); 44 } 45 46 return node; 47 } 48 49 // 节点分裂与插入 50 Node* splitAndInsert(Node* node, int value) { 51 if (node-\u0026gt;isTwoNode) { 52 if (value \u0026lt; node-\u0026gt;val[0]) { 53 node-\u0026gt;val[1] = node-\u0026gt;val[0]; 54 node-\u0026gt;val[0] = value; 55 } else { 56 node-\u0026gt;val[1] = value; 57 } 58 node-\u0026gt;isTwoNode = false; 59 return node; 60 } else { 61 int middleValue; 62 Node* newLeft; 63 Node* newRight; 64 65 if (value \u0026lt; node-\u0026gt;val[0]) { 66 middleValue = node-\u0026gt;val[0]; 67 newLeft = new Node(value); 68 newRight = new Node(node-\u0026gt;val[1]); 69 } else if (value \u0026lt; node-\u0026gt;val[1]) { 70 middleValue = value; 71 newLeft = new Node(node-\u0026gt;val[0]); 72 newRight = new Node(node-\u0026gt;val[1]); 73 } else { 74 middleValue = node-\u0026gt;val[1]; 75 newLeft = new Node(node-\u0026gt;val[0]); 76 newRight = new Node(value); 77 } 78 79 if (node == root) { 80 root = new Node(middleValue); 81 root-\u0026gt;child[0] = newLeft; 82 root-\u0026gt;child[1] = newRight; 83 return root; 84 } else { 85 Node* parent = new Node(middleValue); 86 parent-\u0026gt;child[0] = newLeft; 87 parent-\u0026gt;child[1] = newRight; 88 return parent; 89 } 90 } 91 } 92 93public: 94 TwoThreeTree() { 95 root = nullptr; 96 } 97 98 void insert(int value) { 99 root = insert(root, value); 100 } 101 102 void print(Node* node, int level = 0) { 103 if (node == nullptr) return; 104 print(node-\u0026gt;child[2], level + 1); 105 if (!node-\u0026gt;isTwoNode) { 106 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 107 cout \u0026lt;\u0026lt; node-\u0026gt;val[1] \u0026lt;\u0026lt; endl; 108 } 109 print(node-\u0026gt;child[1], level + 1); 110 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 111 cout \u0026lt;\u0026lt; node-\u0026gt;val[0] \u0026lt;\u0026lt; endl; 112 print(node-\u0026gt;child[0], level + 1); 113 } 114 115 void display() { 116 print(root); 117 } 118}; 119 120int main() { 121 TwoThreeTree tree; 122 int values[] = {10, 20, 5, 6, 12, 30, 7, 17}; 123 124 for (int value : values) { 125 tree.insert(value); 126 } 127 128 tree.display(); 129 130 return 0; 131} 插入图片 先在同级文件目录下放一个文件夹用于储存图片，然后在md文件中引用图片的路径即可。\n居中\n不居中 参考文献 图片插入\n图片插入\n建站指南视频\n建站指南文档\n参考（代码见同名仓库）\n","permalink":"http://localhost:1313/posts/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%BC%95/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%BC%95/","summary":"\u003cp\u003e本篇文章用于记录如何书写新的博文，以及如何使用本博客，以免我未来忘了\u003c/p\u003e\n\u003ch1 id=\"开始写之前\"\u003e开始写之前\u003c/h1\u003e\n\u003cp\u003e如果需要创建博客内容，请使用 hugo new content content/posts/（文章名）/（文章名）.md\u003c/p\u003e","title":"使用方式指引"},{"content":"关于本站 建站基于Hugo和主题PaperMod\n我也不知道要写些什么，就当是随笔吧，记录一下生活\n关于我 一个普通的大学生，啥都喜欢，偶尔玩玩游戏，可以在首页看一下我的B站\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"}]