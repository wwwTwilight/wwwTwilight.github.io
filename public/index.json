[{"content":"网站导航 ","permalink":"http://localhost:1313/posts/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/","summary":"\u003ch1 id=\"网站导航\"\u003e网站导航\u003c/h1\u003e","title":"网站导航"},{"content":"本篇文章用于记录如何书写新的博文，以及如何使用本博客。\n开始写之前 如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\n写文章 博客的书写采用markdown语法，可以参考Markdown语法进行书写。\n数学公式 公式书写与latex相通\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n对于存在3个以上花括号的公式，请用\u0026lt;div\u0026gt;包裹起来。\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 表格的使用 Foo Foo Foo Foo Foo Foo Foo Foo Foo 列表的使用 a b c 代码块的使用 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4class Node { 5public: 6 int val[2]; // 存放节点中的值，最多两个 7 Node* child[3]; // 存放子节点，最多三个 8 bool isTwoNode; // 标记是否为2节点 9 10 Node(int value) { 11 val[0] = value; 12 val[1] = -1; // -1表示没有第二个值 13 for (int i = 0; i \u0026lt; 3; i++) { 14 child[i] = nullptr; 15 } 16 isTwoNode = true; // 初始为2节点 17 } 18 19 bool isLeaf() { 20 return (child[0] == nullptr \u0026amp;\u0026amp; child[1] == nullptr \u0026amp;\u0026amp; child[2] == nullptr); 21 } 22}; 23 24class TwoThreeTree { 25private: 26 Node* root; 27 28 // 插入节点 29 Node* insert(Node* node, int value) { 30 if (node == nullptr) { 31 return new Node(value); 32 } 33 34 if (node-\u0026gt;isLeaf()) { 35 return splitAndInsert(node, value); 36 } 37 38 if (value \u0026lt; node-\u0026gt;val[0]) { 39 node-\u0026gt;child[0] = insert(node-\u0026gt;child[0], value); 40 } else if (node-\u0026gt;isTwoNode || value \u0026lt; node-\u0026gt;val[1]) { 41 node-\u0026gt;child[1] = insert(node-\u0026gt;child[1], value); 42 } else { 43 node-\u0026gt;child[2] = insert(node-\u0026gt;child[2], value); 44 } 45 46 return node; 47 } 48 49 // 节点分裂与插入 50 Node* splitAndInsert(Node* node, int value) { 51 if (node-\u0026gt;isTwoNode) { 52 if (value \u0026lt; node-\u0026gt;val[0]) { 53 node-\u0026gt;val[1] = node-\u0026gt;val[0]; 54 node-\u0026gt;val[0] = value; 55 } else { 56 node-\u0026gt;val[1] = value; 57 } 58 node-\u0026gt;isTwoNode = false; 59 return node; 60 } else { 61 int middleValue; 62 Node* newLeft; 63 Node* newRight; 64 65 if (value \u0026lt; node-\u0026gt;val[0]) { 66 middleValue = node-\u0026gt;val[0]; 67 newLeft = new Node(value); 68 newRight = new Node(node-\u0026gt;val[1]); 69 } else if (value \u0026lt; node-\u0026gt;val[1]) { 70 middleValue = value; 71 newLeft = new Node(node-\u0026gt;val[0]); 72 newRight = new Node(node-\u0026gt;val[1]); 73 } else { 74 middleValue = node-\u0026gt;val[1]; 75 newLeft = new Node(node-\u0026gt;val[0]); 76 newRight = new Node(value); 77 } 78 79 if (node == root) { 80 root = new Node(middleValue); 81 root-\u0026gt;child[0] = newLeft; 82 root-\u0026gt;child[1] = newRight; 83 return root; 84 } else { 85 Node* parent = new Node(middleValue); 86 parent-\u0026gt;child[0] = newLeft; 87 parent-\u0026gt;child[1] = newRight; 88 return parent; 89 } 90 } 91 } 92 93public: 94 TwoThreeTree() { 95 root = nullptr; 96 } 97 98 void insert(int value) { 99 root = insert(root, value); 100 } 101 102 void print(Node* node, int level = 0) { 103 if (node == nullptr) return; 104 print(node-\u0026gt;child[2], level + 1); 105 if (!node-\u0026gt;isTwoNode) { 106 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 107 cout \u0026lt;\u0026lt; node-\u0026gt;val[1] \u0026lt;\u0026lt; endl; 108 } 109 print(node-\u0026gt;child[1], level + 1); 110 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 111 cout \u0026lt;\u0026lt; node-\u0026gt;val[0] \u0026lt;\u0026lt; endl; 112 print(node-\u0026gt;child[0], level + 1); 113 } 114 115 void display() { 116 print(root); 117 } 118}; 119 120int main() { 121 TwoThreeTree tree; 122 int values[] = {10, 20, 5, 6, 12, 30, 7, 17}; 123 124 for (int value : values) { 125 tree.insert(value); 126 } 127 128 tree.display(); 129 130 return 0; 131} 插入图片 先在同级文件目录下放一个文件夹用于储存图片，然后在md文件中引用图片的路径即可。\n居中\n不居中 参考文献 图片插入\n图片插入\n建站指南视频\n建站指南文档\n参考（代码见同名仓库）\n","permalink":"http://localhost:1313/posts/first/first/","summary":"\u003cp\u003e本篇文章用于记录如何书写新的博文，以及如何使用本博客。\u003c/p\u003e\n\u003ch1 id=\"开始写之前\"\u003e开始写之前\u003c/h1\u003e\n\u003cp\u003e如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\u003c/p\u003e","title":"使用方式指引"},{"content":"这里就可以写一些关于的相关信息了。\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"网站导航 ","permalink":"http://localhost:1313/posts/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/","summary":"\u003ch1 id=\"网站导航\"\u003e网站导航\u003c/h1\u003e","title":"网站导航"},{"content":"本篇文章用于记录如何书写新的博文，以及如何使用本博客。\n开始写之前 如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\n写文章 博客的书写采用markdown语法，可以参考Markdown语法进行书写。\n数学公式 公式书写与latex相通\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n对于存在3个以上花括号的公式，请用\u0026lt;div\u0026gt;包裹起来。\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 表格的使用 Foo Foo Foo Foo Foo Foo Foo Foo Foo 列表的使用 a b c 代码块的使用 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4class Node { 5public: 6 int val[2]; // 存放节点中的值，最多两个 7 Node* child[3]; // 存放子节点，最多三个 8 bool isTwoNode; // 标记是否为2节点 9 10 Node(int value) { 11 val[0] = value; 12 val[1] = -1; // -1表示没有第二个值 13 for (int i = 0; i \u0026lt; 3; i++) { 14 child[i] = nullptr; 15 } 16 isTwoNode = true; // 初始为2节点 17 } 18 19 bool isLeaf() { 20 return (child[0] == nullptr \u0026amp;\u0026amp; child[1] == nullptr \u0026amp;\u0026amp; child[2] == nullptr); 21 } 22}; 23 24class TwoThreeTree { 25private: 26 Node* root; 27 28 // 插入节点 29 Node* insert(Node* node, int value) { 30 if (node == nullptr) { 31 return new Node(value); 32 } 33 34 if (node-\u0026gt;isLeaf()) { 35 return splitAndInsert(node, value); 36 } 37 38 if (value \u0026lt; node-\u0026gt;val[0]) { 39 node-\u0026gt;child[0] = insert(node-\u0026gt;child[0], value); 40 } else if (node-\u0026gt;isTwoNode || value \u0026lt; node-\u0026gt;val[1]) { 41 node-\u0026gt;child[1] = insert(node-\u0026gt;child[1], value); 42 } else { 43 node-\u0026gt;child[2] = insert(node-\u0026gt;child[2], value); 44 } 45 46 return node; 47 } 48 49 // 节点分裂与插入 50 Node* splitAndInsert(Node* node, int value) { 51 if (node-\u0026gt;isTwoNode) { 52 if (value \u0026lt; node-\u0026gt;val[0]) { 53 node-\u0026gt;val[1] = node-\u0026gt;val[0]; 54 node-\u0026gt;val[0] = value; 55 } else { 56 node-\u0026gt;val[1] = value; 57 } 58 node-\u0026gt;isTwoNode = false; 59 return node; 60 } else { 61 int middleValue; 62 Node* newLeft; 63 Node* newRight; 64 65 if (value \u0026lt; node-\u0026gt;val[0]) { 66 middleValue = node-\u0026gt;val[0]; 67 newLeft = new Node(value); 68 newRight = new Node(node-\u0026gt;val[1]); 69 } else if (value \u0026lt; node-\u0026gt;val[1]) { 70 middleValue = value; 71 newLeft = new Node(node-\u0026gt;val[0]); 72 newRight = new Node(node-\u0026gt;val[1]); 73 } else { 74 middleValue = node-\u0026gt;val[1]; 75 newLeft = new Node(node-\u0026gt;val[0]); 76 newRight = new Node(value); 77 } 78 79 if (node == root) { 80 root = new Node(middleValue); 81 root-\u0026gt;child[0] = newLeft; 82 root-\u0026gt;child[1] = newRight; 83 return root; 84 } else { 85 Node* parent = new Node(middleValue); 86 parent-\u0026gt;child[0] = newLeft; 87 parent-\u0026gt;child[1] = newRight; 88 return parent; 89 } 90 } 91 } 92 93public: 94 TwoThreeTree() { 95 root = nullptr; 96 } 97 98 void insert(int value) { 99 root = insert(root, value); 100 } 101 102 void print(Node* node, int level = 0) { 103 if (node == nullptr) return; 104 print(node-\u0026gt;child[2], level + 1); 105 if (!node-\u0026gt;isTwoNode) { 106 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 107 cout \u0026lt;\u0026lt; node-\u0026gt;val[1] \u0026lt;\u0026lt; endl; 108 } 109 print(node-\u0026gt;child[1], level + 1); 110 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 111 cout \u0026lt;\u0026lt; node-\u0026gt;val[0] \u0026lt;\u0026lt; endl; 112 print(node-\u0026gt;child[0], level + 1); 113 } 114 115 void display() { 116 print(root); 117 } 118}; 119 120int main() { 121 TwoThreeTree tree; 122 int values[] = {10, 20, 5, 6, 12, 30, 7, 17}; 123 124 for (int value : values) { 125 tree.insert(value); 126 } 127 128 tree.display(); 129 130 return 0; 131} 插入图片 先在同级文件目录下放一个文件夹用于储存图片，然后在md文件中引用图片的路径即可。\n居中\n不居中 参考文献 图片插入\n图片插入\n建站指南视频\n建站指南文档\n参考（代码见同名仓库）\n","permalink":"http://localhost:1313/posts/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%BC%95/first/","summary":"\u003cp\u003e本篇文章用于记录如何书写新的博文，以及如何使用本博客。\u003c/p\u003e\n\u003ch1 id=\"开始写之前\"\u003e开始写之前\u003c/h1\u003e\n\u003cp\u003e如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\u003c/p\u003e","title":"使用方式指引"},{"content":"这里就可以写一些关于的相关信息了。\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"网站导航 ","permalink":"http://localhost:1313/posts/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/","summary":"\u003ch1 id=\"网站导航\"\u003e网站导航\u003c/h1\u003e","title":"网站导航"},{"content":"本篇文章用于记录如何书写新的博文，以及如何使用本博客。\n开始写之前 如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\n写文章 博客的书写采用markdown语法，可以参考Markdown语法进行书写。\n数学公式 公式书写与latex相通\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n对于存在3个以上花括号的公式，请用\u0026lt;div\u0026gt;包裹起来。\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 表格的使用 Foo Foo Foo Foo Foo Foo Foo Foo Foo 列表的使用 a b c 代码块的使用 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4class Node { 5public: 6 int val[2]; // 存放节点中的值，最多两个 7 Node* child[3]; // 存放子节点，最多三个 8 bool isTwoNode; // 标记是否为2节点 9 10 Node(int value) { 11 val[0] = value; 12 val[1] = -1; // -1表示没有第二个值 13 for (int i = 0; i \u0026lt; 3; i++) { 14 child[i] = nullptr; 15 } 16 isTwoNode = true; // 初始为2节点 17 } 18 19 bool isLeaf() { 20 return (child[0] == nullptr \u0026amp;\u0026amp; child[1] == nullptr \u0026amp;\u0026amp; child[2] == nullptr); 21 } 22}; 23 24class TwoThreeTree { 25private: 26 Node* root; 27 28 // 插入节点 29 Node* insert(Node* node, int value) { 30 if (node == nullptr) { 31 return new Node(value); 32 } 33 34 if (node-\u0026gt;isLeaf()) { 35 return splitAndInsert(node, value); 36 } 37 38 if (value \u0026lt; node-\u0026gt;val[0]) { 39 node-\u0026gt;child[0] = insert(node-\u0026gt;child[0], value); 40 } else if (node-\u0026gt;isTwoNode || value \u0026lt; node-\u0026gt;val[1]) { 41 node-\u0026gt;child[1] = insert(node-\u0026gt;child[1], value); 42 } else { 43 node-\u0026gt;child[2] = insert(node-\u0026gt;child[2], value); 44 } 45 46 return node; 47 } 48 49 // 节点分裂与插入 50 Node* splitAndInsert(Node* node, int value) { 51 if (node-\u0026gt;isTwoNode) { 52 if (value \u0026lt; node-\u0026gt;val[0]) { 53 node-\u0026gt;val[1] = node-\u0026gt;val[0]; 54 node-\u0026gt;val[0] = value; 55 } else { 56 node-\u0026gt;val[1] = value; 57 } 58 node-\u0026gt;isTwoNode = false; 59 return node; 60 } else { 61 int middleValue; 62 Node* newLeft; 63 Node* newRight; 64 65 if (value \u0026lt; node-\u0026gt;val[0]) { 66 middleValue = node-\u0026gt;val[0]; 67 newLeft = new Node(value); 68 newRight = new Node(node-\u0026gt;val[1]); 69 } else if (value \u0026lt; node-\u0026gt;val[1]) { 70 middleValue = value; 71 newLeft = new Node(node-\u0026gt;val[0]); 72 newRight = new Node(node-\u0026gt;val[1]); 73 } else { 74 middleValue = node-\u0026gt;val[1]; 75 newLeft = new Node(node-\u0026gt;val[0]); 76 newRight = new Node(value); 77 } 78 79 if (node == root) { 80 root = new Node(middleValue); 81 root-\u0026gt;child[0] = newLeft; 82 root-\u0026gt;child[1] = newRight; 83 return root; 84 } else { 85 Node* parent = new Node(middleValue); 86 parent-\u0026gt;child[0] = newLeft; 87 parent-\u0026gt;child[1] = newRight; 88 return parent; 89 } 90 } 91 } 92 93public: 94 TwoThreeTree() { 95 root = nullptr; 96 } 97 98 void insert(int value) { 99 root = insert(root, value); 100 } 101 102 void print(Node* node, int level = 0) { 103 if (node == nullptr) return; 104 print(node-\u0026gt;child[2], level + 1); 105 if (!node-\u0026gt;isTwoNode) { 106 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 107 cout \u0026lt;\u0026lt; node-\u0026gt;val[1] \u0026lt;\u0026lt; endl; 108 } 109 print(node-\u0026gt;child[1], level + 1); 110 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 111 cout \u0026lt;\u0026lt; node-\u0026gt;val[0] \u0026lt;\u0026lt; endl; 112 print(node-\u0026gt;child[0], level + 1); 113 } 114 115 void display() { 116 print(root); 117 } 118}; 119 120int main() { 121 TwoThreeTree tree; 122 int values[] = {10, 20, 5, 6, 12, 30, 7, 17}; 123 124 for (int value : values) { 125 tree.insert(value); 126 } 127 128 tree.display(); 129 130 return 0; 131} 插入图片 先在同级文件目录下放一个文件夹用于储存图片，然后在md文件中引用图片的路径即可。\n居中\n不居中 参考文献 图片插入\n图片插入\n建站指南视频\n建站指南文档\n参考（代码见同名仓库）\n","permalink":"http://localhost:1313/posts/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%BC%95/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%BC%95/","summary":"\u003cp\u003e本篇文章用于记录如何书写新的博文，以及如何使用本博客。\u003c/p\u003e\n\u003ch1 id=\"开始写之前\"\u003e开始写之前\u003c/h1\u003e\n\u003cp\u003e如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\u003c/p\u003e","title":"使用方式指引"},{"content":"这里就可以写一些关于的相关信息了。\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"由于本人十分厌恶浏览器的收藏功能，这篇将会收录一些比较有用的网站，供日常使用\n网站导航 ","permalink":"http://localhost:1313/posts/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/","summary":"\u003cp\u003e由于本人十分厌恶浏览器的收藏功能，这篇将会收录一些比较有用的网站，供日常使用\u003c/p\u003e\n\u003ch1 id=\"网站导航\"\u003e网站导航\u003c/h1\u003e","title":"网站导航"},{"content":"本篇文章用于记录如何书写新的博文，以及如何使用本博客。\n开始写之前 如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\n写文章 博客的书写采用markdown语法，可以参考Markdown语法进行书写。\n数学公式 公式书写与latex相通\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n对于存在3个以上花括号的公式，请用\u0026lt;div\u0026gt;包裹起来。\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 表格的使用 Foo Foo Foo Foo Foo Foo Foo Foo Foo 列表的使用 a b c 代码块的使用 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4class Node { 5public: 6 int val[2]; // 存放节点中的值，最多两个 7 Node* child[3]; // 存放子节点，最多三个 8 bool isTwoNode; // 标记是否为2节点 9 10 Node(int value) { 11 val[0] = value; 12 val[1] = -1; // -1表示没有第二个值 13 for (int i = 0; i \u0026lt; 3; i++) { 14 child[i] = nullptr; 15 } 16 isTwoNode = true; // 初始为2节点 17 } 18 19 bool isLeaf() { 20 return (child[0] == nullptr \u0026amp;\u0026amp; child[1] == nullptr \u0026amp;\u0026amp; child[2] == nullptr); 21 } 22}; 23 24class TwoThreeTree { 25private: 26 Node* root; 27 28 // 插入节点 29 Node* insert(Node* node, int value) { 30 if (node == nullptr) { 31 return new Node(value); 32 } 33 34 if (node-\u0026gt;isLeaf()) { 35 return splitAndInsert(node, value); 36 } 37 38 if (value \u0026lt; node-\u0026gt;val[0]) { 39 node-\u0026gt;child[0] = insert(node-\u0026gt;child[0], value); 40 } else if (node-\u0026gt;isTwoNode || value \u0026lt; node-\u0026gt;val[1]) { 41 node-\u0026gt;child[1] = insert(node-\u0026gt;child[1], value); 42 } else { 43 node-\u0026gt;child[2] = insert(node-\u0026gt;child[2], value); 44 } 45 46 return node; 47 } 48 49 // 节点分裂与插入 50 Node* splitAndInsert(Node* node, int value) { 51 if (node-\u0026gt;isTwoNode) { 52 if (value \u0026lt; node-\u0026gt;val[0]) { 53 node-\u0026gt;val[1] = node-\u0026gt;val[0]; 54 node-\u0026gt;val[0] = value; 55 } else { 56 node-\u0026gt;val[1] = value; 57 } 58 node-\u0026gt;isTwoNode = false; 59 return node; 60 } else { 61 int middleValue; 62 Node* newLeft; 63 Node* newRight; 64 65 if (value \u0026lt; node-\u0026gt;val[0]) { 66 middleValue = node-\u0026gt;val[0]; 67 newLeft = new Node(value); 68 newRight = new Node(node-\u0026gt;val[1]); 69 } else if (value \u0026lt; node-\u0026gt;val[1]) { 70 middleValue = value; 71 newLeft = new Node(node-\u0026gt;val[0]); 72 newRight = new Node(node-\u0026gt;val[1]); 73 } else { 74 middleValue = node-\u0026gt;val[1]; 75 newLeft = new Node(node-\u0026gt;val[0]); 76 newRight = new Node(value); 77 } 78 79 if (node == root) { 80 root = new Node(middleValue); 81 root-\u0026gt;child[0] = newLeft; 82 root-\u0026gt;child[1] = newRight; 83 return root; 84 } else { 85 Node* parent = new Node(middleValue); 86 parent-\u0026gt;child[0] = newLeft; 87 parent-\u0026gt;child[1] = newRight; 88 return parent; 89 } 90 } 91 } 92 93public: 94 TwoThreeTree() { 95 root = nullptr; 96 } 97 98 void insert(int value) { 99 root = insert(root, value); 100 } 101 102 void print(Node* node, int level = 0) { 103 if (node == nullptr) return; 104 print(node-\u0026gt;child[2], level + 1); 105 if (!node-\u0026gt;isTwoNode) { 106 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 107 cout \u0026lt;\u0026lt; node-\u0026gt;val[1] \u0026lt;\u0026lt; endl; 108 } 109 print(node-\u0026gt;child[1], level + 1); 110 for (int i = 0; i \u0026lt; level; i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 111 cout \u0026lt;\u0026lt; node-\u0026gt;val[0] \u0026lt;\u0026lt; endl; 112 print(node-\u0026gt;child[0], level + 1); 113 } 114 115 void display() { 116 print(root); 117 } 118}; 119 120int main() { 121 TwoThreeTree tree; 122 int values[] = {10, 20, 5, 6, 12, 30, 7, 17}; 123 124 for (int value : values) { 125 tree.insert(value); 126 } 127 128 tree.display(); 129 130 return 0; 131} 插入图片 先在同级文件目录下放一个文件夹用于储存图片，然后在md文件中引用图片的路径即可。\n居中\n不居中 参考文献 图片插入\n图片插入\n建站指南视频\n建站指南文档\n参考（代码见同名仓库）\n","permalink":"http://localhost:1313/posts/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%BC%95/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%BC%95/","summary":"\u003cp\u003e本篇文章用于记录如何书写新的博文，以及如何使用本博客。\u003c/p\u003e\n\u003ch1 id=\"开始写之前\"\u003e开始写之前\u003c/h1\u003e\n\u003cp\u003e如果需要创建博客内容，请使用 hugo new content /content/posts/（文章名）/（文章名）.md\u003c/p\u003e","title":"使用方式指引"},{"content":"这里就可以写一些关于的相关信息了。\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"}]